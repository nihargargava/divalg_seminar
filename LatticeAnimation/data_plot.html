<!DOCTYPE html>
<!-- Picked from before -->
<!-- It took me a lot of time trying to make mathJax work with d3js. -->
<!-- I took help from this blog: -->
<!-- https://www.thesoftwaresimpleton.com/blog/2016/05/25/sine-wave -->
<!-- After a lot of profanity, I finally managed to make it. It had been emotional. -->

<!-- In this script, I will attempt to create a d3js demonstration to lay out my data -->


<meta charset="utf-8">

<link rel="stylesheet" href="../dist/theme/white.css" id="theme">


<body style='overflow: hidden;'>

  <script src="//d3js.org/d3.v3.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_SVG">
  </script>


<script>
//
//For making things of a preset ratio
const windowRatio = 0.8;

//For dynamically adjusting ratio
// const screenRatio = window.innerHeight/window.innerWidth;
var margin = 
	//{top: 50, right: 20, bottom: 50, left: 20},
	{top: 0, right: 0, bottom: 0, left: 0};
    // width = 960 - margin.left - margin.right,
    // height = 500 - margin.top - margin.bottom;
    //width = Math.min(600, window.innerWidth - margin.left - margin.right - 10),
    //height = Math.min(600 - margin.top - margin.bottom, window.innerHeight - margin.top - margin.bottom);
	

	width = window.innerWidth;
	height = window.innerWidth*windowRatio;
    

//Set transit speed
var transitDuration  = 3000;
var scaleForCode = 5;
//x and y functions take domain as shown and currectly spit out the right coordinates
var x = d3.scale.linear()
    .domain([scaleForCode*(-0.08), scaleForCode])
    .range([0, width]);

//x and y functions take domain as shown and currectly spit out the right coordinates
var y = d3.scale.linear()
    .domain([scaleForCode*(-0.08)*windowRatio, scaleForCode*windowRatio]) //adjusted by windowRatio
    .range([height, 0]);

//sets up the svg element to be located correctly
var oursvg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom);



//some constants
const cRadius='2px';
const cRadius1='2px';
const cRadius2=x(0.5)-x(0);
const color1='black'
const color2='blue'
const color3='red'
const color4='orange'

// initial scaling
var C_1=0.6
var C_2=0.015

//some markings and label text on the axes:
xlabels=[7.5,100,1000];
ylabels=[10,100,1000];

// line to connect to x-axis
oursvg.selectAll('rect')
	.data(xlabels)
	.enter().append('line')
		.attr('class',d => "xmark")
		.attr('data',d => d ) //It remembers data
		.attr('x1',d => x(d*C_1))
		.attr('y1',y(0))
		.attr('x2',d => x(d*C_1))
		.attr('y2',d => y(-0.05))
		.attr('stroke',color4)
		.attr('opacity',1.0)
		.attr('stroke-width','1px');


// x-axis label text
oursvg.selectAll('rect')
	.data(xlabels)
	.enter().append('g')
		.attr("class", d => "xmark_text")
		.attr('data',d => d) //It remembers data
		.attr("opacity", 1.0)
		.attr('transform', d=> " translate(" + x(d*C_1)+ " ,"+y(-0.03)+")") 
		.attr("font-size","0.6em")
		.append("g")
			.attr("class", "tick")
			.append("text")  	
			.text(d => "\\("+d+"\\)");


// line to connect to y-axis
oursvg.selectAll('rect')
	.data(ylabels)
	.enter().append('line')
		.attr('class',d => "ymark")
		.attr('data',d => d ) //It remembers data
		.attr('y1',d => y(d*C_2))
		.attr('x1',x(0))
		.attr('y2',d => y(d*C_2))
		.attr('x2',d => x(-0.05))
		.attr('stroke',color4)
		.attr('opacity',1.0)
		.attr('stroke-width','1px');


// y-axis label text
oursvg.selectAll('rect')
	.data(ylabels)
	.enter().append('g')
		.attr("class", d => "ymark_text")
		.attr('data',d => d) //It remembers data
		.attr("opacity", 1.0)
		.attr('transform', d=> " translate(" + x(-0.3)+ " ,"+y(d*C_2)+")") 
		.attr("font-size","0.6em")
		.append("g")
			.attr("class", "tick")
			.append("text")  	
			.text(d => "\\("+d+"\\)");




const plot_these_points =  (darray,type) => {
// A class attribute keeps track of what kind of point it is
// Data attribute keeps track of the original data
// Add a point for each data entry
oursvg.selectAll('rect')
	.data(darray)
	.enter().append('circle')
		.attr('class',d => type)
		.attr('data',d => [d.d,d.c_d]) //It remembers data
		.attr('cx',d=>x(d.d*C_1))
		.attr('cy',d=>y(d.c_d*C_2))
		.attr('r',d => cRadius)
    		.attr('fill',d => color1)
		.attr('opacity',1);


// Just a line to connect it to y-axis
oursvg.selectAll('rect')
	.data(darray)
	.enter().append('line')
		.attr('class',d => type)
		.attr('data',d => [d.d,d.c_d]) //It remembers data
		.attr('x1',d => x(d.d*C_1))
		.attr('y1',y(0))
		.attr('x2',d => x(d.d*C_1))
		.attr('y2',d => y(d.c_d*C_2))
		.attr('stroke',color2)
		.attr('opacity',1.0)
		.attr('stroke-width','1px');


// Just a label on each data point
oursvg.selectAll('rect')
	.data(darray)
	.enter().append('g')
		.attr("class", d => type+"_text")
		.attr('data',d => [d.d,d.c_d]) //It remembers data
		.attr("opacity", 1.0)
		.attr('transform', d=> " translate(" + x(d.d*C_1)+ " ,"+y(-0.03)+")") 
		.attr("font-size","0.6em")
		.append("g")
		.attr("class", "tick")
		.append("text")  	
		.text(d => "\\("+d.d+"\\)");

};

//x-axis 
oursvg.append('line')
	.attr('class','xaxis')
	.attr('x1',x(0))
	.attr('y1',y(0))
	.attr('x2',x(10))
	.attr('y2',y(0))
	.attr('stroke',color1)
	.attr('opacity',1.0)
	.attr('stroke-width','3px');

//y-axis 
oursvg.append('line')
	.attr('class','yaxis')
	.attr('x1',x(0))
	.attr('y1',y(0))
	.attr('x2',x(0))
	.attr('y2',y(8))
	.attr('stroke',color1)
	.attr('opacity',1.0)
	.attr('stroke-width','3px');


// This is total "Judaad". In order to manipulate this text, I have put it in a container called xlabel. The other texts are similar
 oursvg.append("g")
  .attr("class", "xlabel")
  .attr("opacity", 1.0)
  .attr('transform', " translate(" + x(1.6)+ " ,"+y(-0.1)+")") 
  .attr("font-size","1.2em")
	.append("g")
      	.attr("class", "tick")
      	.append("text")  	
	.text("\\(\\text{Dimension of packing\ } d\\)");

//ylabel text
 oursvg.append("g")
  .attr("class", "ylabel")
  .attr("opacity", 1.0)
  .attr('transform', " translate(" + x(-0.35)+ " ,"+y(2.1)+")") 
  .attr("font-size","1.2em")
	.append("g")
      	.attr("class", "tick")
      	.append("text")  	
	.text("\\(c_d\\)");

// ylabel will change and become this in the text soon
 oursvg.append("g")
  .attr("class", "ylabel2")
  .attr("opacity", 0.0)
  .attr('transform', " translate(" + x(-0.35)+ " ,"+y(2.1)+")") 
  .attr("font-size","1.2em")
	.append("g")
      	.attr("class", "tick")
      	.append("text")  	
	.text("\\(\\frac{c_d}{d}\\)");


// To keep track of types of data points
type_list=[];

// Draw data from a file, perform our operation
d3.csv("data/known_dims.csv", function(data){
    //code dealing with data here
	plot_these_points(data,"known");
	type_list.push("known");
});


//Transition a change of radius
//function changeradius(newradius){
//	//perform transition on each lattice point
//	d3.selectAll('circle.Lpoint').each(function(d,i){
//		d3.select(this)
//		.transition().duration(transitDuration)
//			.attr('r',newradius);
//	});
//}

//Transition a change of color
//function changecolor(newcolor){
//	//perform transition on each lattice point
//	d3.selectAll('circle.Lpoint').each(function(d,i){
//		d3.select(this)
//		.transition().duration(transitDuration)
//			.attr('fill',newcolor);
//	});
//}


//Interpolate translate of non-svg elements can be done through this function
// See https://stackoverflow.com/questions/24030267/d3-transition-for-transform-translate-not-working-for-div#25247387
// This function will take a class name of a text object (see the Jugaad above)
// and it will perform a string interpolation to do the movement smoothly
function moveText(Tname,xnew,ynew)
{
			var startTransform = d3.selectAll(Tname).attr('transform');
			var endTransform = " translate(" + xnew+ ","+ynew+")";
			var translateInterpolator = d3.interpolateString(startTransform, endTransform);
			d3.selectAll(Tname)
				.transition().duration(transitDuration)
				.attrTween('transform' , function(d){ return translateInterpolator });
			console.log("While moving text");
			console.log(startTransform);
}

function changeOpacity(Tname,onew)
{
			d3.selectAll(Tname)
				.transition().duration(transitDuration)
				.attr('opacity' , onew );
}


//Just linear scaling on x and y
// default is when C_1 = 0.1, C_2 = 0.001
function map_linear(C_1,C_2,d){
	var a1 = d[0]*C_1;
	var a2 = d[1]*C_2;
	return [a1,a2];
}

function map_linear1(d){
	return map_linear(0.1,0.001,d);
}

//y-axis is constant multiple of x-axis and x is logarithmic
function map_logx_rely(C,d){
	var a1 = Math.log(d[0])*C
	var a2 = d[1]/d[0]
	return [a1,a2];
}

//logarithmic scaling wrt constant C
function map_logx(C,d){
	var a1 = Math.log(d[0])*C
	var a2 = d[1]
	return [a1,a2];
}

// Change scaling with respect to a scale function for all points of a given type
// A scale function must take input as a 2d vector and output a 2d vector
function transto(scalfunc){


	// Adjust marker labels and text
  	d3.selectAll("line.xmark").each(function(d,i){
  		//This number is obtained as a string intitially
  		var Bcoordstr = d3.select(this)
  				.attr('data')
  					.split(',') ;
  		//so now we store it as an array of numbers
  		var Bcoord = [+Bcoordstr[0],+Bcoordstr[1]];
  		var newcoord = scalfunc(Bcoord);
  		d3.select(this)
       			.transition().duration(transitDuration)
  				.attr('x1',x(newcoord[0]))
  				.attr('y1',y(0))
  				.attr('x2',x(newcoord[0]))
  				.attr('y2',y(newcoord[1]));
  	});
  	
  	// then label text should be moved
  	d3.selectAll("g."+type+"_text").each(function(d,i){
  		//This number is obtained as a string intitially
  		var Bcoordstr = d3.select(this)
  				.attr('data')
  					.split(',') ;
  		//so now we store it as an array of numbers
  		var Bcoord = [+Bcoordstr[0],+Bcoordstr[1]];
  		var newcoord = scalfunc(Bcoord);
		// this idea has been picked from
		// https://stackoverflow.com/questions/24030267/d3-transition-for-transform-translate-not-working-for-div#25247387
		var startTransform = d3.select(this).attr('transform');
		var endTransform = " translate(" + x(newcoord[0])+ ","+y(-0.03)+")";
		var translateInterpolator = d3.interpolateString(startTransform, endTransform);
		d3.select(this)
			.transition().duration(transitDuration)
			.attrTween('transform' , function(d){ return translateInterpolator });
  	});



	// change each data type point for each type in type_list
	type_list.forEach( type =>
	{
  	//perform transformation to each point, indicator line, and label text
  	//first points

  	d3.selectAll("circle."+type).each(function(d,i){
  		//This number is obtained as a string intitially
  		var Bcoordstr = d3.select(this)
  				.attr('data')
  					.split(',') ;
  		//so now we store it as an array of numbers
  		var Bcoord = [+Bcoordstr[0],+Bcoordstr[1]];
  		var newcoord = scalfunc(Bcoord);
  		d3.select(this)
       			.transition().duration(transitDuration)
  				.attr('cx',x(newcoord[0]))
  				.attr('cy',y(newcoord[1]));
  	});
  	
  	// then indicator lines
  	d3.selectAll("line."+type).each(function(d,i){
  		//This number is obtained as a string intitially
  		var Bcoordstr = d3.select(this)
  				.attr('data')
  					.split(',') ;
  		//so now we store it as an array of numbers
  		var Bcoord = [+Bcoordstr[0],+Bcoordstr[1]];
  		var newcoord = scalfunc(Bcoord);
  		d3.select(this)
       			.transition().duration(transitDuration)
  				.attr('x1',x(newcoord[0]))
  				.attr('y1',y(0))
  				.attr('x2',x(newcoord[0]))
  				.attr('y2',y(newcoord[1]));
  	});
  	
  	// then label text should be moved
  	d3.selectAll("g."+type+"_text").each(function(d,i){
  		//This number is obtained as a string intitially
  		var Bcoordstr = d3.select(this)
  				.attr('data')
  					.split(',') ;
  		//so now we store it as an array of numbers
  		var Bcoord = [+Bcoordstr[0],+Bcoordstr[1]];
  		var newcoord = scalfunc(Bcoord);
		// this idea has been picked from
		// https://stackoverflow.com/questions/24030267/d3-transition-for-transform-translate-not-working-for-div#25247387
		var startTransform = d3.select(this).attr('transform');
		var endTransform = " translate(" + x(newcoord[0])+ ","+y(-0.03)+")";
		var translateInterpolator = d3.interpolateString(startTransform, endTransform);
		d3.select(this)
			.transition().duration(transitDuration)
			.attrTween('transform' , function(d){ return translateInterpolator });
  	});

  	}
  	);

}


//Initializing everything 


var _transitions = [
	{
		//empty transition
		transitionForward: () => {
			transto(d => map_linear(0.1,0.0001,d));
		},
		transitionBackward:() => {
			transto(d => map_linear(0.6,0.015,d));
		}
	},
	{
		//empty transition
		transitionForward: () => {
			console.log("Fifth and empty");
		},
		transitionBackward:() => {
		}
	},
	{
		//empty transition
		transitionForward: () => {
			console.log("Fifth and empty");
		},
		transitionBackward:() => {
		}
	}
];


//mathjax is stupid and it won't automatically parse the SVG file
//it has to be told seperately to make my equations readable throughout the text
// the following is copied from https://gist.github.com/larsenmtl/86077bddc91c3de8d3db6a53216b2f47
setTimeout(() => {
  
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  
  MathJax.Hub.Register.StartupHook("End", function() {
    setTimeout(() => {
          oursvg.selectAll('.tick').each(function(){
          var self = d3.select(this),
              g = self.select('text>span>svg');
          g.remove();
          self.append(function(){
            return g.node();
          });
        });
      }, 1);
    });
  
  MathJax.Hub.Queue(["Typeset", MathJax.Hub, oursvg.node()]);
  
}, 1);

</script>
